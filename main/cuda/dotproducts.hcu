#if !defined(_DOT_PRODUCTS_HCU_)
#define _DOT_PRODUCTS_HCU_

// // template<class TYPE, const int T1, const int T2, const int N_UNROLL>
// __device__ __inline__ void _dev_dotproducts(TYPE A[N_UNROLL*TILESIZEY][T1],
// 					    TYPE B[N_UNROLL*TILESIZEY][T2],
// 					    TYPE (&Creg)[N_UNROLL*N_UNROLL]) {

//   TYPE t1, t2;
//   for (int m=0; m<N_UNROLL; ++m) {
//     for (int n=0; n<N_UNROLL; ++n) {
//       int i = m*N_UNROLL + n;
// #pragma unroll
//       for (int k=0; k<TILESIZE; ++k) {
// 	t1 = A[threadIdx.y*N_UNROLL + m][k];
// 	t2 = B[threadIdx.x*N_UNROLL + n][k];
// 	Creg[i] = fma(t1,t2,Creg[i]);
//       }
//     }
//   }
// }


// template<class TYPE, const int LENGTH, const int T1, const int T2, const int N_UNROLL>
// __device__ __inline__ void _dev_dotproductsF(TYPE A[N_UNROLL*TILESIZEY][T1],
// 					     TYPE B[N_UNROLL*TILESIZEY][T2],
// 					     TYPE (&Creg)[N_UNROLL*N_UNROLL]) {
//   TYPE t1, t2;

//   for (int m=0; m<N_UNROLL; ++m) {
//     for (int n=0; n<N_UNROLL; ++n) {
//       int i = m*N_UNROLL + n;
// #pragma unroll
//       for (int k=0; k<LENGTH; ++k) {
// 	t1 = A[threadIdx.y*N_UNROLL + m][k];
// 	t2 = B[threadIdx.x*N_UNROLL + n][k];
// 	Creg[i] = fma(t1,t2,Creg[i]);
//       }
//     }
//   }
// }


template<const int T1, const int T2>
__device__ __inline__ void _dev_dotproducts(float2 A[TILESIZEY][T1],
					    float2 B[TILESIZEY][T2],
					    float2 * Creg) {

  float2 t1, t2;
  for (int k=0; k<TILESIZE; ++k) {
    t1 = A[threadIdx.y][k];
    t2 = B[threadIdx.x][k];
    Creg[0] = fma<float,float2>(t1.x,t2,Creg[0]);
    Creg[1] = fma<float,float2>(t1.y,t2,Creg[1]);
  }
}

template<const int T1, const int T2>
__device__ __inline__ void _dev_dotproducts(double2 A[TILESIZEY][T1],
					    double2 B[TILESIZEY][T2],
					    double2 * Creg) {

  double2 t1, t2;
  for (int k=0; k<TILESIZE; ++k) {
    t1 = A[threadIdx.y][k];
    t2 = B[threadIdx.x][k];
    Creg[0] = fma<double,double2>(t1.x,t2,Creg[0]);
    Creg[1] = fma<double,double2>(t1.y,t2,Creg[1]);
  }
}


template<const int T1, const int T2>
__device__ __inline__ void _dev_dotproducts(float4 A[TILESIZEY][T1],
					    float4 B[TILESIZEY][T2],
					    float4 * Creg) {
#if 1

#pragma unroll
  for (int k=0; k<TILESIZE; k+=2) {
    float8 * a = reinterpret_cast<float8 *>(&(A[threadIdx.y][k]));
    float8 d1 = a[0];

    float8 * b = reinterpret_cast<float8 *>(&(B[threadIdx.x][k]));
    float8 d2 = b[0];
    float4 t1 = make_float4(d2.a, d2.b, d2.c, d2.d);
    float4 t2 = make_float4(d2.e, d2.f, d2.g, d2.h);

    Creg[0] = fma<float,float4>(d1.a,t1,Creg[0]);
    Creg[1] = fma<float,float4>(d1.b,t1,Creg[1]);
    Creg[2] = fma<float,float4>(d1.c,t1,Creg[2]);
    Creg[3] = fma<float,float4>(d1.d,t1,Creg[3]);

    Creg[0] = fma<float,float4>(d1.e,t2,Creg[0]);
    Creg[1] = fma<float,float4>(d1.f,t2,Creg[1]);
    Creg[2] = fma<float,float4>(d1.g,t2,Creg[2]);
    Creg[3] = fma<float,float4>(d1.h,t2,Creg[3]);
  }

#else

  float4 t1, t2;
#pragma unroll
  for (int k=0; k<TILESIZE; ++k) {
    t1 = A[threadIdx.y][k];
    t2 = B[threadIdx.x][k];
    
    Creg[0] = fma<float,float4>(t1.x,t2,Creg[0]);
    Creg[1] = fma<float,float4>(t1.y,t2,Creg[1]);
    Creg[2] = fma<float,float4>(t1.z,t2,Creg[2]);
    Creg[3] = fma<float,float4>(t1.w,t2,Creg[3]);
  }
#endif
}


template<const int T1, const int T2>
__device__ __inline__ void _dev_dotproducts(double4 A[TILESIZEY][T1],
					    double4 B[TILESIZEY][T2],
					    double4 * Creg) {

  double4 t1, t2;
#pragma unroll
  for (int k=0; k<TILESIZE; ++k) {
    t1 = A[threadIdx.y][k];
    t2 = B[threadIdx.x][k];
    Creg[0] = fma<double,double4>(t1.x,t2,Creg[0]);
    Creg[1] = fma<double,double4>(t1.y,t2,Creg[1]);
    Creg[2] = fma<double,double4>(t1.z,t2,Creg[2]);
    Creg[3] = fma<double,double4>(t1.w,t2,Creg[3]);
  }
}

template<const int LENGTH, const int T1, const int T2>
__device__ __inline__ void _dev_dotproductsF(float4 A[TILESIZEY][T1],
					     float4 B[TILESIZEY][T2],
					     float4 * Creg) {
  float4 t1, t2;
#pragma unroll
  for (int k=0; k<LENGTH; ++k) {
    t1 = A[threadIdx.y][k];
    t2 = B[threadIdx.x][k];

    Creg[0] = fma<float,float4>(t1.x,t2,Creg[0]);
    Creg[1] = fma<float,float4>(t1.y,t2,Creg[1]);
    Creg[2] = fma<float,float4>(t1.z,t2,Creg[2]);
    Creg[3] = fma<float,float4>(t1.w,t2,Creg[3]);
  }
}


template<const int LENGTH, const int T1, const int T2>
__device__ __inline__ void _dev_dotproductsF(double4 A[TILESIZEY][T1],
					     double4 B[TILESIZEY][T2],
					     double4 * Creg) {
  double4 t1, t2;
  for (int k=0; k<LENGTH; ++k) {
    t1 = A[threadIdx.y][k];
    t2 = B[threadIdx.x][k];
    Creg[0] = fma<double,double4>(t1.x,t2,Creg[0]);
    Creg[1] = fma<double,double4>(t1.y,t2,Creg[1]);
    Creg[2] = fma<double,double4>(t1.z,t2,Creg[2]);
    Creg[3] = fma<double,double4>(t1.w,t2,Creg[3]);
  }
}

template<const int LENGTH, const int T1, const int T2>
__device__ __inline__ void _dev_dotproductsF(float2 A[TILESIZEY][T1],
					     float2 B[TILESIZEY][T2],
					     float2 * Creg) {
  float2 t1, t2;
  for (int k=0; k<LENGTH; ++k) {
    t1 = A[threadIdx.y][k];
    t2 = B[threadIdx.x][k];
    Creg[0] = fma<float,float2>(t1.x,t2,Creg[0]);
    Creg[1] = fma<float,float2>(t1.y,t2,Creg[1]);
  }
}

template<const int LENGTH, const int T1, const int T2>
__device__ __inline__ void _dev_dotproductsF(double2 A[TILESIZEY][T1],
					     double2 B[TILESIZEY][T2],
					     double2 * Creg) {
  double2 t1, t2;
  for (int k=0; k<LENGTH; ++k) {
    t1 = A[threadIdx.y][k];
    t2 = B[threadIdx.x][k];
    Creg[0] = fma<double,double2>(t1.x,t2,Creg[0]);
    Creg[1] = fma<double,double2>(t1.y,t2,Creg[1]);
  }
}


#endif /* !defined(_DOT_PRODUCTS_HCU_) */
